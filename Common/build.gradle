apply plugin: 'fabric-loom'
apply plugin: 'io.github.juuxel.loom-quiltflower'

archivesBaseName = rootProject.name
version = "v${modVersion}-${libs.versions.minecraft.get()}-Common"
group = modMavenGroup

dependencies {
    minecraft "com.mojang:minecraft:${libs.versions.minecraft.get()}"
    mappings loom.layered() {
        officialMojangMappings()
        parchment("org.parchmentmc.data:parchment-${libs.versions.parchmentMinecraft.get()}:${libs.versions.parchment.get()}@zip")
    }

    // Puzzles Lib
    modApi ("fuzs.puzzleslib:puzzleslib-common:${libs.versions.puzzles.get()}")
}

loom {
    accessWidenerPath = project(":Fabric").file("src/main/resources/${modId}.accesswidener")

    mixin {
        // not sure if this is necessary for common...
        defaultRefmapName = "${modId}.refmap.json"
        // fix for java.lang.NoClassDefFoundError: org/objectweb/asm/tree/MethodNode
        useLegacyMixinAp = false
    }

    // this should hopeful prevent an empty run directory being generated in common during initial project setup
    runs {
        client {
            client()
            setConfigName("Common Client")
            ideConfigGenerated(false)
            runDir("../run")
        }
        server {
            server()
            setConfigName("Common Server")
            ideConfigGenerated(false)
            runDir("../run")
        }
    }
}

processResources {
    from(project(":Fabric").sourceSets.main.resources) {
        include("fabric.mod.json")
        include("${modId}.accesswidener")
    }

    duplicatesStrategy DuplicatesStrategy.INCLUDE

    // this will ensure that this task is redone when a value changes
    inputs.property "modId", modId
    inputs.property "modName", modName
    inputs.property "modVersion", modVersion
    inputs.property "modDescription", modDescription
    inputs.property "modGroup", project.group
    inputs.property "modPageUrl", modSourceUrl
    inputs.property "modIssueUrl", modIssueUrl
    inputs.property "modAuthor", modAuthor
    inputs.property "modLicense", modLicense
    inputs.property "minFabricVersion", libs.versions.minFabric.get()
    inputs.property "minFabricApiVersion", libs.versions.minFabricApi.get()
    inputs.property "minecraftVersion", libs.versions.minecraft.get()
    inputs.property "minPuzzlesVersion", libs.versions.minPuzzles.get()
    inputs.property "resourcePackFormat", libs.versions.resources.get()
    inputs.property "dataPackFormat", libs.versions.data.get()
    inputs.property "mainEntryPoint", "${project.group}.${rootProject.name}Fabric"
    inputs.property "clientEntryPoint", "${project.group}.client.${rootProject.name}FabricClient"
    inputs.property "modFabricEnvironment", modFabricEnvironment

    // replace stuff in fabric.mod.json
    filesMatching('fabric.mod.json') {
        expand(
                'modId': modId,
                'modName': modName,
                'modVersion': modVersion,
                'modDescription': modDescription,
                'modGroup': project.group,
                'modPageUrl': modSourceUrl,
                'modIssueUrl': modIssueUrl,
                'modAuthor': modAuthor,
                'modLicense': modLicense,
                'minFabricVersion': libs.versions.minFabric.get(),
                'minFabricApiVersion': libs.versions.minFabricApi.get(),
                'minecraftVersion': libs.versions.minecraft.get(),
                "minPuzzlesVersion": libs.versions.minPuzzles.get(),
                "mainEntryPoint": "${project.group}.${rootProject.name}Fabric",
                "clientEntryPoint": "${project.group}.client.${rootProject.name}FabricClient",
                "modFabricEnvironment": modFabricEnvironment
        )
    }

    // replace stuff in pack.mcmeta
    filesMatching('pack.mcmeta') {
        expand(
                'modDescription': modDescription,
                "resourcePackFormat": libs.versions.resources.get(),
                "dataPackFormat": libs.versions.data.get()
        )
    }
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifactId = "${modId}-common"
            version = modVersion
            from components.java
            pom {
                name = "${modName} [Common]"
                description = "${modDescription}"
                url = "${modSourceUrl}"
                scm {
                    url = "${modSourceUrl}"
                    connection = "${modSourceUrl}".replace("https", "scm:git:git").concat(".git")
                    developerConnection = "${modSourceUrl}".replace("https://github.com/", "scm:git:git@github.com:").concat(".git")
                }
                issueManagement {
                    system = 'github'
                    url = "${modIssueUrl}"
                }
                licenses {
                    license {
                        name = "${modLicense}"
                        url = "https://spdx.org/licenses/${modLicense}.html"
                    }
                }
                developers {
                    developer {
                        id = "${modAuthor}".toLowerCase()
                        name = "${modAuthor}"
                    }
                }
            }
        }
    }
    repositories {
        maven {
            name = 'FuzsModResources'
            url "file://" + project.hasProperty('modResources') ? "${project.findProperty('modResources')}/maven" : System.getenv('local_maven')
        }
    }
}

signing {
    sign publishing.publications.mavenJava
}

import net.fabricmc.loom.task.AbstractRemapJarTask

// thanks to lukebemish for this comment: https://github.com/jaredlll08/MultiLoader-Template/issues/17#issuecomment-1221598082
tasks.withType(AbstractRemapJarTask).each {
    it.targetNamespace = "named"
}

task copyJarToDir(type: Copy) {
    onlyIf { project.hasProperty('buildJarOutputDir') && project.hasProperty('uniqueBuildNumber') }
    if (project.findProperty('copyBuildJar').toBoolean()) {
        from remapJar
        into project.findProperty('buildJarOutputDir')
        // add build number to be able to distinguish jars when testing thorough official launcher
        // build number is stored in global gradle.properties
        rename { fileName -> fileName.replace("v${modVersion}", "v${modVersion}.${uniqueBuildNumber}") }
    }
}

build.finalizedBy project.tasks.copyJarToDir, rootProject.tasks.incrementBuildNumber
